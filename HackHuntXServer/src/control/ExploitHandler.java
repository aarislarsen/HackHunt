/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package control;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Properties;
import java.util.Timer;
import java.util.logging.Level;
import java.util.logging.Logger;
import model.PatchMaker;
import model.ScoreSystem;
import util.Constants;
import util.InputValidator;

/**
 *
 * @author Dragon
 */
public class ExploitHandler 
{
    private final InputValidator inputValidator = new InputValidator();
    private final String logname = "HackHunt Log";
    private final Logger log = Logger.getLogger(logname);
    private Level INFO = Level.INFO;
    private Level DEBUG = Level.FINE;
    private Level WARNING = Level.WARNING;
    private final String propertiesURL = "properties.properties";
    private Properties properties = new Properties();
    private ScoreSystem scoreSystem = new ScoreSystem();
    
    /**
     * default constructor
     */
    public ExploitHandler()
    {
        initProperties();
        configureLogLevels();
    }
    
    /**
     * gets the exploit status for the exploits available to the token user
     * @param token the users authenticated token
     * @return 
     */
    public synchronized String getExploitStatus(String token)
    {
        log.log(DEBUG,"Retrieving exploit status");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(isPlayerAuthenticated(token))
        {
            SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
            String returnString = "";
            for(String s : sql.getExploitStatus(sql.getActivePlayerByToken(token).get(0).get(0).toString()))
            {
                returnString += s+";";
            }            
            return "SUCCESS: " + returnString;            
        }
        else
        {
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * generates an exploit
     * @param token
     * @param vulnerability
     * @return success if generated, error description otherwise
     */
    public synchronized String generateExploit(String token, String vulnerability)
    {
        log.log(DEBUG,"Generating exploit");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(!inputValidator.isValidInput(Constants.ALLOWEDINSTRINGS, vulnerability))
        {
            log.log(DEBUG,"Invalid character in vulnerability");
            return "ERROR: Invalid characters in vulnerability, please try again";
        }
        if(isPlayerAuthenticated(token))
        {
            SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
            String username = sql.getActivePlayerByToken(token).get(0).get(0).toString();
            if(sql.didUserAlreadyGenerateThisPatch(username, vulnerability) || sql.didUserAlreadyGenerateThisExploit(username, vulnerability))
            {
                return "ERROR: You've already generated this exploit, or chose to develop a patch";
            }
            else
            {
                boolean offerPatch = false;
                if(!sql.hasExploitBeenCreated(vulnerability))
                {
                    offerPatch = true;
                }
                if(sql.generateExploit(sql.getActivePlayerByToken(token).get(0).get(0).toString(), vulnerability))
                {                    
                    if(offerPatch)
                    {
                        new PatchMaker().createPatchMaker(vulnerability);
                        sql.addAnnouncement(username + " developed an exploit for the " + vulnerability + " vulnerability");                        
                        sql.addAnnouncement("A public patch will be made available for the " + vulnerability + " vulnerability in " + (Integer.parseInt(properties.getProperty("PatchDelay"))) + " seconds");
                    }
                    return "SUCCESS: " + vulnerability;
                }
                else
                {
                    return "ERROR: Could not generate exploit. Have you answered all the required advisories?";
                }
            }            
        }
        else
        {
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * generates a patch
     * @param token
     * @param vulnerability
     * @return success if generated, error description otherwise
     */
    public synchronized String generatePatch(String token, String vulnerability)
    {
        log.log(DEBUG,"Generating patch");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(!inputValidator.isValidInput(Constants.ALLOWEDINSTRINGS, vulnerability))
        {
            log.log(DEBUG,"Invalid character in vulnerability");
            return "ERROR: Invalid characters in vulnerability, please try again";
        }
        if(isPlayerAuthenticated(token))
        {            
            SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
            String username = sql.getActivePlayerByToken(token).get(0).get(0).toString();
            if(sql.didUserAlreadyGenerateThisPatch(username, vulnerability) || sql.didUserAlreadyGenerateThisExploit(username, vulnerability))
            {
                return "ERROR: You've already generated this patch or chose to develop the exploit";
            }
            else
            {
                if(sql.generatePatch(sql.getActivePlayerByToken(token).get(0).get(0).toString(), vulnerability))
                {
                    scoreSystem.addCredit(username);
                    return "SUCCESS: " + vulnerability;
                }
                else
                {
                    return "ERROR: Could not generate patch. Have you answered all the required advisories?";
                }
            }            
        }
        else
        {
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * Reveals if the user has access to the exploit
     * @param token
     * @param username
     * @return a comma-separated list of exploits
     */
    public synchronized String isExploitAvailable(String token, String username, String vulnerability)
    {
        log.log(DEBUG,"Getting available exploits");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(!inputValidator.isValidInput(Constants.ALLOWEDINSTRINGS, vulnerability))
        {
            log.log(DEBUG,"Invalid character in vulnerability");
            return "ERROR: Invalid characters in vulnerability, please try again";
        }
        if(!inputValidator.isValidInput(Constants.ALLOWEDINUSERNAME, username))
        {
            log.log(DEBUG,"Invalid character in username");
            return "ERROR: Invalid characters in username, please try again";
        }
        if(isPlayerAuthenticated(token))
        {            
            String returnString = "SUCCESS: ";
            SQLiteConnectionHandler sql = new SQLiteConnectionHandler();            
            
            returnString += sql.didUserAlreadyGenerateThisExploit(username,vulnerability);
            return returnString;
        }
        else
        {
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * gets vulnerable targets to a specific vuln
     * @param token
     * @param vulnerability
     * @return a string of usernames
     */
    public synchronized String getVulnerableTargets(String token, String vulnerability)
    {
        log.log(DEBUG,"Getting vulnerable targets");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(!inputValidator.isValidInput(Constants.ALLOWEDINSTRINGS, vulnerability))
        {
            log.log(DEBUG,"Invalid character in vulnerability");
            return "ERROR: Invalid characters in vulnerability, please try again";
        }
        if(isPlayerAuthenticated(token))
        {            
            String returnString = "SUCCESS: ";
            SQLiteConnectionHandler sql = new SQLiteConnectionHandler();            
            for(String s : sql.getVulnerableTargets(vulnerability))
            {
                returnString += s+";";
            }            
            return returnString;
        }
        else
        {
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * gets vulnerable targets to a specific vuln in the specified team
     * @param token
     * @param vulnerability
     * @param teamname
     * @return a string of usernames
     */
    public synchronized String getVulnerableTargetsInTeam(String token, String vulnerability, String teamname)
    {
        log.log(DEBUG,"Getting vulnerable targets");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(!inputValidator.isValidInput(Constants.ALLOWEDINSTRINGS, vulnerability))
        {
            log.log(DEBUG,"Invalid character in vulnerability");
            return "ERROR: Invalid characters in vulnerability, please try again";
        }
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTEAMNAME, teamname))
        {
            log.log(DEBUG,"Invalid character in teamname");
            return "ERROR: Invalid characters in teamname, please try again";
        }
        if(isPlayerAuthenticated(token))
        {            
            String returnString = "SUCCESS: ";
            SQLiteConnectionHandler sql = new SQLiteConnectionHandler();            
            for(String s : sql.getVulnerableTargetsInTeam(vulnerability,teamname))
            {
                returnString += s+";";
            }            
            return returnString;
        }
        else
        {
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * attacks a vulnerable target
     * @param token
     * @param vulnerability
     * @param username
     * @return SUCCESS if it works, ERROR if not
     */
    public synchronized String attackTarget(String token, String vulnerability, String username)
    {
        log.log(DEBUG,"Attacking vulnerable target");
        //input validation
        if(!inputValidator.isValidInput(Constants.ALLOWEDINTOKEN, token))
        {
            log.log(DEBUG,"Invalid character in token");
            return "ERROR: Invalid characters in token, please try again";
        }  
        if(!inputValidator.isValidInput(Constants.ALLOWEDINSTRINGS, vulnerability))
        {
            log.log(DEBUG,"Invalid character in vulnerability");
            return "ERROR: Invalid characters in vulnerability, please try again";
        }
        if(!inputValidator.isValidInput(Constants.ALLOWEDINUSERNAME, username))
        {
            log.log(DEBUG,"Invalid character in username");
            return "ERROR: Invalid characters in username, please try again";
        }
        if(isPlayerAuthenticated(token))
        {                  
            if(doesPlayerHaveExploit(token, vulnerability))
            {                
                if(!isPlayerPatched(username, vulnerability))
                {                    
                    String affectedService = serviceAffectedByVulnerability(vulnerability);
                    if(!isServiceDown(username, affectedService))
                    {                        
                        SQLiteConnectionHandler sql = new SQLiteConnectionHandler();       
                        if(sql.disableTeamsService(sql.getTeamWithThisMember(username), affectedService))
                        {
                            String playername = sql.getActivePlayerByToken(token).get(0).get(0).toString();
                            String teamname = sql.getTeamWithThisMember(username);
                            sql.addAnnouncement(teamname + "'s "+ affectedService +" was exploited using the " + vulnerability + " exploit against " + username + ".");
                            scoreSystem.addCredit(playername);
                            return "SUCCESS: " + username + "'s "+ affectedService +" was exploited using the " + vulnerability + " exploit.";                        
                        }
                        else
                        {
                            return "ERROR: target service could not be disabled";
                        }
                    }
                    else
                    {
                        log.log(DEBUG, "Service is already down or target doesn't exist");
                        return "ERROR: Target could not be exploited, service is already down or the target could not be found. Do you have the right target?";
                    }
                }
                else
                {
                    log.log(DEBUG, "Player is patched");
                    return "ERROR: Target could not be exploited, the target is patched against this vulnerability";
                }
            }
            else
            {
                log.log(DEBUG, "Player doesnt have the needed exploit");
                return "ERROR: Target could not be exploited, you don't have the needed exploit";
            }                
        }
        else
        {
            log.log(DEBUG, "Player is not authenticated");
            return "ERROR: You must be logged in to perform this action";
        }
    }
    
    /**
     * checks to see if the user has the exploit
     * @param token 
     * @param vulnerability
     * @return true if the user with that token has the vulnerability with that identifier, false if not
     */
    private boolean doesPlayerHaveExploit(String token, String vulnerability)
    {
        SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
        return sql.didUserAlreadyGenerateThisExploit(sql.getActivePlayerByToken(token).get(0).get(0).toString(), vulnerability);
    }
    
    /**
     * checks to see if the player is patched against the vulnerability
     * @param username
     * @param vulnerability
     * @return true if patched, false if not
     */
    private boolean isPlayerPatched(String username, String vulnerability)
    {
        SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
        if(sql.getActivePlayerByUsername(username).size() < 1)
        {
            return false;
        }
        return sql.didUserAlreadyGenerateThisPatch(sql.getActivePlayerByUsername(username).get(0).get(0).toString(),vulnerability);
    }
    
    /**
     * checks if the service belonging the team with the player with the provided username, is down
     * @param username
     * @param service
     * @return true if the service is down, false if not
     */
    private boolean isServiceDown(String username, String service)
    {   
        boolean isServiceDown = true;
        SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
        ArrayList<HashMap<String,String>> services = sql.getServicesForTeamWithPlayer(username);
        if(services.size() < 1)
        {
            return isServiceDown;
        }
        else
        {
            boolean  onOrOff = services.get(0).get(service).toString().equalsIgnoreCase("0");
            if(onOrOff)
            {
                return true;
            }
            else
            {
                return false;
            }        
        }        
    }
    
    /**
     * gets the service name that the vulnerability affects
     * @param vulnerability
     * @return the service name
     */
    private String serviceAffectedByVulnerability(String vulnerability)
    {
        SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
        String affectedService = sql.getServiceAffectedByVulnerability(vulnerability);
        log.log(DEBUG,"Affected service is " + affectedService);
        return affectedService;
    }
    
    /**
     * checks to see if at least one token is present in the active players database
     * @param token
     * @return true if the token was found, false otherwise
     */
    private synchronized boolean isPlayerAuthenticated(String token)
    {
        SQLiteConnectionHandler sql = new SQLiteConnectionHandler();
        ArrayList<ArrayList> foundTokens = sql.getActivePlayerByToken(token);
        boolean tokenInUse = false;
        for(ArrayList a : foundTokens)
        {
            if(a.get(1).toString().trim().equalsIgnoreCase(token))
            {                    
                log.log(DEBUG,"Users token found");
                tokenInUse = true;
                break;
            }
        }
        return tokenInUse;
    }
    
    /**
     * loads the properties from the file
     */
    private void initProperties()
    {
        try
        {
            properties.load(new FileInputStream(propertiesURL));
        }
        catch (IOException ex)
        {
            log.log(DEBUG,""+ex);
        }
    }
    
    /**
     * configures the LogLevel based on the properties file
     */
    private void configureLogLevels()
    {        
        String level = properties.getProperty("LogLevel");
        
        switch(level)
        {
            case "INFO":    INFO = Level.INFO; 
                            DEBUG = Level.FINE; 
                            WARNING = Level.FINE;
                            break;
            case "DEBUG":   INFO = Level.INFO;
                            DEBUG = Level.INFO; 
                            WARNING = Level.INFO;
                            break;
            case "WARNING": INFO = Level.FINE; 
                            DEBUG = Level.FINE; 
                            WARNING = Level.INFO;    
                            break;
            default:        INFO = Level.INFO; 
                            DEBUG = Level.FINE; 
                            WARNING = Level.WARNING;
                            break;
        }
    }
    
}
